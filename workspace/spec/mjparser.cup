package rs.ac.bg.etf.pp1.sv110059;

import java_cup.runtime.*;
import java.io.*;


parser code {:
	//promenljive za brojanje pojavljivanja odredjenih elemenata
	
	int globalCharVarCount = 0; //TODO: R40
	int globalArrayCount = 0; //R41
	int funcCount = 0; //R42
	int classCount = 0; //R43
	int statementBlocks = 0; //R44
	int funcCallsInMain = 0; //TODO: R45
	int newStatementCount = 0; //R46
	int classMethodCount = 0; //R47
	int classFieldCount = 0; //R48
	int classDerivationCount = 0; //R49

    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
    boolean greska;
     
   public void report_fatal_error(String message, Object   info) throws java.lang.Exception {
   	  greska=true;
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

  public void report_error(String message, Object info)
    {
      greska=true;
      System.err.print(message);
      System.err.flush();
      if (info instanceof Symbol)
          System.err.println(" na liniji " + ((Symbol)info).left);
      else System.err.println("");
    }
    
    public void printCounts() {
    	System.out.println("Broj elemenata: ");
    	System.out.println("Deklaracije globalnih nizova - " + globalArrayCount);
    	System.out.println("Definicije funkcija u glavnom programu - " + funcCount);
    	System.out.println("Definicije unutrasnjih klasa - " + classCount);
    	System.out.println("Blokovi naredbi - " + statementBlocks);
    	System.out.println("Naredbe stvaranja objekta - " + newStatementCount);
    	System.out.println("Definicije metoda unutrasnjih klasa - " + classMethodCount);
    	System.out.println("Definicije polja unutrasnjih klasa - " + classFieldCount);
    	System.out.println("Izvodjenja klasa - " + classDerivationCount);
    }
    
    public static void main(String args[]) throws Exception {
        FileReader r = new FileReader(args[0]);
        Yylex skener = new Yylex(r);
        MJParser p = new MJParser(skener);
        Symbol s = p.parse();  //pocetak parsiranja
        if (p.greska) 
        	System.out.println("Ulazni program ima gresaka!");
        else {
        	p.printCounts();
        	System.out.println("Parsiranje uspesno zavrseno!");
        }
    }
    
:}


action code {:

	boolean global = true;
	boolean classDef = false;
	boolean methodDef = false;
	
:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		System.out.println(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROGRAM, LBRACE, RBRACE, SEMI, LPAREN, RPAREN, COMMA, PRINT, RETURN, PLUS, EQUAL, VOID ;
terminal EXTENDS, GT, GTE, LT, LTE, NEW, DIV, MOD, MINUS, NOT_EQUAL, IS_EQUAL, CONST, AND, LSQUARE, RSQUARE, OR, TIMES ;
terminal BREAK, INC, DEC, WHILE, CLASS, CHARCONST, BOOLCONST, STRCONST, ELSE, IF, READ, DOT ;
terminal Integer NUMBER ;
terminal String IDENT ;

non terminal Program, VarDeclList, MethodDeclList, VarDecl, Type, MethodDecl, GlobalVarDecl, GlobalVarList ;
non terminal FormPars, Addop, Factor ;
non terminal StatementList, Statement, Designator, Expr, Term ;
non terminal Unmatched, Matched ;
non terminal Rhs, DeclarationList, DeclarationPart, ConstDecl, VarList, Var, ConstPart ;
non terminal ClassDecl, Ext, ClassMethods, Parameter, FormalParams, ReturnType, FunctionCall, IdentList, IdentRef ;
non terminal DesignatorsFollowUp, Condition, OptNumbers, ActPars, CondTerm, CondFact, Relop, Sign, AddList, MulList, Mulop, ActParams ;

Program ::= PROGRAM IDENT DeclarationList LBRACE {:
						global = false;
					:} MethodDeclList RBRACE ;

DeclarationList	::=  DeclarationList DeclarationPart
					|
					/* epsilon */
					;

DeclarationPart	::=  ConstDecl
					|    
					GlobalVarDecl
					|
					ClassDecl
					;

ConstDecl ::= CONST Type ConstPart SEMI
				|
			CONST error SEMI {: System.err.println("Uspesan oporavak od greske pri definiciji globalne promenljive konst1."); :}
				 ;
				 
ConstPart ::= IDENT EQUAL Rhs
				|
				IDENT error
				|
			  ConstPart COMMA IDENT EQUAL Rhs
			  //	|
			 // 	error COMMA IDENT EQUAL Rhs {: System.err.println("Uspesan oporavak od greske pri definiciji globalne promenljive konst2."); :}
				;
				
Rhs ::= NUMBER
			|
			CHARCONST
			|
			BOOLCONST
			|
			STRCONST
			;

GlobalVarDecl ::= Type GlobalVarList SEMI
				|
			Type error SEMI {: System.err.println("Uspesan oporavak od greske pri definiciji globalne promenljive 1."); :}
				;

VarDecl ::= Type VarList SEMI
				|
			Type error SEMI {: System.err.println("Uspesan oporavak od greske pri deklaraciji lokalne promenljive/polja unutrasnje klase."); :}
				|
			Type error  {: System.err.println("Uspesan oporavak od greske pri deklaraciji lokalne promenljive/polja unutrasnje klase."); :}
				;

GlobalVarList ::= GlobalVarList COMMA Var
					|
					Var
					| 
					error COMMA Var {: System.err.println("Uspesan oporavak od greske pri definiciji globalne promenljive 2."); :}
					;

VarList ::= VarList COMMA Var
					|
					Var
					;
					
Var ::= IDENT
		|
		IDENT LSQUARE RSQUARE {:
			if (global && !classDef)
				parser.globalArrayCount++;
		:}
		;

Type ::= IDENT ;

ClassDecl ::= CLASS IDENT Ext LBRACE {:
					classDef = true;
				:} VarDeclList ClassMethods RBRACE {:
					parser.classCount++;
					classDef = false;
				:}
				;

Ext ::= EXTENDS Type {:
			parser.classDerivationCount++;
		:}
		|
		error {: System.err.println("Uspesan oporavak od greske pri deklaraciji prosirenja natklase."); :}
		|
		/* epsilon */
		;
		
VarDeclList ::= VarDeclList VarDecl {:
					if (classDef && !methodDef) {
						parser.classFieldCount++;
					}
				:}
				|
				/* epsilon */
				;
				
ClassMethods ::= LBRACE MethodDeclList RBRACE
				|
				/* epsilon */
				;



MethodDeclList ::= MethodDeclList MethodDecl
					|
					/* epsilon */
					;

MethodDecl ::= ReturnType IDENT LPAREN FormalParams RPAREN {:
					methodDef = true;
				:} VarDeclList LBRACE StatementList RBRACE {:
					methodDef = false;
					if (!classDef)
						parser.funcCount++;
					else
						parser.classMethodCount++;
					
					parser.statementBlocks++;
				:}
				;

ReturnType ::= Type
				|
				VOID
				;

FormalParams ::= FormPars
				|
				/* epsilon */
				;

FormPars  ::=  FormPars COMMA Parameter
		     		|    
		     		Parameter
		     		;

Parameter  ::=  Type IDENT
	            |
	            Type IDENT LSQUARE RSQUARE
	            |
	            error {: System.err.println("Uspesan oporavak od greske pri deklaraciji formalnog parametra funkcije."); :}
	            ;

StatementList ::= StatementList Statement
					|
					/* epsilon */
					;

Statement ::= Matched | Unmatched ;

 

Matched ::= Designator DesignatorsFollowUp SEMI
				|
			Designator LPAREN ActParams RPAREN SEMI
				|
			Designator LPAREN error RPAREN SEMI {: System.err.println("Uspesan oporavak od greske pri zadavanju liste parametara u pozivu funkcije."); :}
				|
			Designator LPAREN error SEMI {:  System.err.println("Uspesan oporavak od greske pri pozivu funkcije."); :}
				|
				Designator EQUAL error SEMI
				{: System.err.println("Uspesan oporavak od greske pri dodeli vrednosti."); :}
				|
				RETURN Expr SEMI
				|
				RETURN SEMI
				|
				IF LPAREN Condition RPAREN Matched ELSE Matched
				|
				IF LPAREN error RPAREN Matched ELSE Matched {:  System.err.println("Uspesan oporavak od greske unutar izraza u if konstrukciji."); :}
				|
				WHILE LPAREN Condition RPAREN Matched
				|
				WHILE LPAREN error RPAREN Matched {: System.err.println("Uspesan oporavak od greske unutar izraza u while konstrukciji."); :}
				|
				BREAK SEMI
				|
				READ LPAREN Designator RPAREN SEMI
				|
				PRINT LPAREN Expr OptNumbers RPAREN SEMI
				|
				LBRACE StatementList RBRACE  {:
						parser.statementBlocks++;
					:}
				;
				
OptNumbers ::= OptNumbers COMMA NUMBER
				|
				/* epsilon */
				;
				
ActParams ::= ActPars
				|
				/* epsilon */
				;
				
ActPars ::= ActPars COMMA Expr
			|
			Expr
			;
			
Condition ::= Condition OR CondTerm
				|
				CondTerm
				;
				
CondTerm ::= CondTerm AND CondFact
				|
				CondFact
				;
				
CondFact ::= CondFact Relop Expr
				|
				Expr
				;
				
Expr ::= Sign Term AddList ;

Sign ::= MINUS | /* epsilon */ ;

AddList ::= AddList Addop Term
			|
			/* epsilon */
			;
			
Term ::= Factor MulList ;

MulList ::= MulList Mulop Factor
			|
			/* epsilon */
			;
			
Factor ::= Designator FunctionCall
			|
			NUMBER
			|
			CHARCONST
			|
			BOOLCONST
			|
			STRCONST
			|
			NEW Type {:
				parser.newStatementCount++;
			:}
			|
			NEW Type LSQUARE Expr RSQUARE
			|
			LPAREN Expr RPAREN
			;

FunctionCall ::= LPAREN ActParams RPAREN
				|
				/* epsilon */
				;
				
DesignatorsFollowUp ::= EQUAL Expr
						|
						INC
						|
						DEC
						;
				
Unmatched ::= IF LPAREN Condition RPAREN Statement
			 |
			 IF LPAREN error RPAREN Statement {:  System.err.println("Uspesan oporavak od greske unutar izraza u if konstrukciji."); :}
			 | 
			 IF LPAREN Condition RPAREN Matched ELSE Unmatched
			 |
			 IF LPAREN error RPAREN Matched ELSE Unmatched {:  System.err.println("Uspesan oporavak od greske unutar izraza u if konstrukciji."); :}
			 |
			 WHILE LPAREN Condition RPAREN Unmatched
			 |
			 WHILE LPAREN error RPAREN Unmatched {: System.err.println("Uspesan oporavak od greske unutar izraza u while konstrukciji."); :}
			 ;
					
Designator ::= IDENT IdentList;

IdentList ::= IdentList IdentRef
				|
				/* epsilon */
				;
				
IdentRef ::= DOT IDENT
			|
			LSQUARE Expr RSQUARE
			|
			LSQUARE error RSQUARE {:  System.err.println("Uspesan oporavak od greske pri indeksiranju niza."); :}
			;

Relop ::= IS_EQUAL
			|
			NOT_EQUAL
			|
			GT
			|
			GTE
			|
			LT
			|
			LTE
			;

Addop ::= PLUS
			|
			MINUS
			;
			
Mulop ::= TIMES
			|
			DIV
			|
			MOD
			;