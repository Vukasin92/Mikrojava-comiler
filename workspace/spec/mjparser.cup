package rs.ac.bg.etf.pp1.sv110059;

import java_cup.runtime.*;
import java.io.*;
import rs.etf.pp1.symboltable.*;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.symboltable.visitors.*;


parser code {:
	//promenljive za brojanje pojavljivanja odredjenih elemenata
	
	int globalCharVarCount = 0; //TODO: R40
	int globalArrayCount = 0; //R41
	int funcCount = 0; //R42
	int classCount = 0; //R43
	int statementBlocks = 0; //R44
	int funcCallsInMain = 0; //TODO: R45
	int newStatementCount = 0; //R46
	int classMethodCount = 0; //R47
	int classFieldCount = 0; //R48
	int classDerivationCount = 0; //R49

    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
    boolean greska;
     
   public void report_fatal_error(String message, Object   info) throws java.lang.Exception {
   	  greska=true;
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info)
    {
      greska=true;
      System.err.print(message);
      System.err.flush();
      if (info instanceof Symbol)
          System.err.println(" na liniji " + ((Symbol)info).left);
      else System.err.println("");
    }
    
    public void report_info(String message, Object info)
    {
      System.out.print(message);
      System.out.flush();
      if (info instanceof Symbol)
          System.out.println(" na liniji " + ((Symbol)info).left);
      else System.out.println("");
    }
   
   	DumpSymbolTableVisitor dstv = new DumpSymbolTableVisitor();
   	
   	public void report_error(String symName, int line, String msg) {
   	  greska=true;
      System.err.print("Greska na "+line+"("+symName+"), "+msg);
      System.err.flush();
      System.err.println("");
   	}
   	
    public void report_info(String symName, int line, Obj obj) {
    	  dstv.visitObjNode(obj);
    	  System.out.print("Pretraga na "+line+"("+symName+"), nadjeno "+dstv.getOutput());
	      System.out.flush();
	      System.out.println("");
    }
    
    
    public void printCounts() {
    	System.out.println("Broj elemenata: ");
    	System.out.println("Deklaracije globalnih nizova - " + globalArrayCount);
    	System.out.println("Definicije funkcija u glavnom programu - " + funcCount);
    	System.out.println("Definicije unutrasnjih klasa - " + classCount);
    	System.out.println("Blokovi naredbi - " + statementBlocks);
    	System.out.println("Naredbe stvaranja objekta - " + newStatementCount);
    	System.out.println("Definicije metoda unutrasnjih klasa - " + classMethodCount);
    	System.out.println("Definicije polja unutrasnjih klasa - " + classFieldCount);
    	System.out.println("Izvodjenja klasa - " + classDerivationCount);
    }
    
    public static void main(String args[]) throws Exception {
        FileReader r = new FileReader(args[0]);
        Yylex skener = new Yylex(r);
        MJParser p = new MJParser(skener);
       // Symbol s = p.debug_parse();  //pocetak parsiranja
       Symbol s = p.parse();
       
        if (p.greska) {
        	 Tab.dump();
        	System.out.println("Ulazni program ima gresaka!");
        }
        else {
        	System.out.println("==================SINTAKSNA ANALIZA====================");
        	p.printCounts();
        	Tab.dump();
        	System.out.println("Parsiranje uspesno zavrseno!");
        }
        
    }
    
:}


action code {:

	boolean global = true;
	boolean classDef = false;
	boolean methodDef = false;
	Struct var_type=Tab.noType;
	Obj currentMethod = null;
	boolean returnFound = false;
	int currentLevel = -1;
	boolean isVoid=false;
	Obj curr_ident = null;
	Obj[] actualParameters = null;
	
:}

init with {:
	Tab.init();
	System.out.println("==================SEMANTICKA OBRADA====================");
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	return s;
:}

terminal PROGRAM, LBRACE, RBRACE, SEMI, LPAREN, RPAREN, COMMA, PRINT, RETURN, PLUS, EQUAL, VOID ;
terminal EXTENDS, GT, GTE, LT, LTE, NEW, DIV, MOD, MINUS, NOT_EQUAL, IS_EQUAL, CONST, AND, LSQUARE, RSQUARE, OR, TIMES ;
terminal BREAK, INC, DEC, WHILE, CLASS, CHARCONST, BOOLCONST, STRCONST, ELSE, IF, READ, DOT ;
terminal Integer NUMBER ;
terminal String IDENT ;

non terminal Program, VarDeclList, MethodDeclList, VarDecl, MethodDecl, GlobalVarDecl, GlobalVarList ;
non terminal FormPars, Addop, Var ;
non terminal StatementList, Statement ;
non terminal Unmatched, Matched, ConstVar ;
non terminal Rhs, DeclarationList, DeclarationPart, ConstDecl, VarList, ConstPart ;
non terminal ClassDecl, Ext, ClassMethods, Parameter, FormalParams, IdentList, IdentRef ;
non terminal DesignatorsFollowUp, Condition, OptNumbers, ActPars, CondTerm, CondFact, Relop, Sign, Mulop, ActParams ;
//non terminal String Var, ConstVar;

non terminal Obj ProgName, Designator;
non terminal Struct Type, ReturnType, Term, Expr, Factor, AddList, MulList;

Program ::= PROGRAM ProgName:p DeclarationList LBRACE {:
						global = false;
					:} MethodDeclList RBRACE
{:
	Tab.chainLocalSymbols(p);
	Tab.closeScope();
	currentLevel--;
:};

ProgName ::= IDENT:pName
{:
	RESULT = Tab.insert(Obj.Prog, pName, Tab.noType);
	Tab.openScope();
	currentLevel++;
:};

DeclarationList	::=  DeclarationList DeclarationPart
					|
					/* epsilon */
					;

DeclarationPart	::=  ConstDecl
					|    
					GlobalVarDecl
					|
					ClassDecl
					;

ConstDecl ::= CONST Type ConstPart SEMI
				|
			CONST error:l SEMI {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" pri definiciji globalne promenljive tipa konstante",null); :}
				 ;
				 
ConstPart ::= ConstVar EQUAL Rhs
				|
				ConstVar error:l
{:
	parser.report_error("Izvrsen oporavak do ; u linij "+lleft+" pri definiciji konstante.", null);
:}
				|
			  ConstPart COMMA ConstVar EQUAL Rhs

			  //	|
			 // 	error COMMA IDENT EQUAL Rhs {: parser.report_error("Uspesan oporavak od greske pri definiciji globalne promenljive konst2.", null); :}
				;

ConstVar ::= IDENT:varName
{:
	Obj temp = Tab.find(varName);
	if (temp.getLevel() == currentLevel) {
		parser.report_error("Semanticka greska na liniji "+varNameleft+": redefinicija promenljive "+varName, null);
	}
	else {
		Tab.insert(Obj.Con, varName, var_type);
		parser.report_info("Deklarisana promenljiva "+varName+" na liniji "+varNameleft, null);
	}
:}
;
		
Rhs ::= NUMBER
			|
			CHARCONST
			|
			BOOLCONST
			|
			STRCONST
			;

GlobalVarDecl ::= Type GlobalVarList SEMI
				|
			Type:varType error:l SEMI {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" pri definiciji globalne promenljive",null); :}
			;

VarDecl ::= Type VarList SEMI
				|
			Type error:l SEMI {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" pri definiciji lokalne promenljive/polja unutrasnje klase",null); :}
				|
			Type error:l  {: parser.report_error("Izvrsen oporavak do { u liniji "+lleft+" pri definiciji lokalne promenljive/polja unutrasnje klase",null); :}
				;

GlobalVarList ::= GlobalVarList COMMA Var
					|
					Var:varName
					| 
					error:l COMMA Var 
					;

VarList ::= VarList COMMA Var
					|
					Var
					;
					
Var ::= IDENT:varName
{:
	Obj temp = Tab.find(varName);
	if (temp.getLevel() == currentLevel) {
		parser.report_error("Semanticka greska na liniji "+varNameleft+": redefinicija promenljive "+varName, null);
	}
	else {
		Tab.insert(Obj.Var, varName, var_type);
		parser.report_info("Deklarisana promenljiva "+varName+" na liniji "+varNameleft, null);
	}
:}
		|
		IDENT:varName LSQUARE RSQUARE 
{:
			if (global && !classDef)
				parser.globalArrayCount++;

			Obj temp = Tab.find(varName);
			if (temp.getLevel() == currentLevel) {
				parser.report_error("Semanticka greska na liniji "+varNameleft+": redefinicija promenljive "+varName, null);
			}
			else {
				Tab.insert(Obj.Var, varName, new Struct(Struct.Array, var_type));
				parser.report_info("Deklarisana promenljiva "+varName+" na liniji "+varNameleft, null);
			}
:}
		;

Type ::= IDENT:typeName
{:
	
	Obj typeNode = Tab.find(typeName);
	if (typeNode == Tab.noObj) {
		parser.report_error("Semanticka greska na liniji "+typeNameleft+ ": Nije pronadjen tip " + typeName + " u tabeli simbola.", null);
		var_type = RESULT = Tab.noType;
	}
	else {
		if (Obj.Type == typeNode.getKind()) {
			var_type = RESULT = typeNode.getType();
		}
		else {
			parser.report_error("Semanticka greska na liniji "+typeNameleft+ ": Ime " + typeName + " ne predstavlja tip.", null);
			var_type = RESULT = Tab.noType;
		}
	}
:};

ClassDecl ::= CLASS IDENT Ext LBRACE {:
					classDef = true;
				:} VarDeclList ClassMethods RBRACE {:
					parser.classCount++;
					classDef = false;
				:}
				;

Ext ::= EXTENDS Type {:
			parser.classDerivationCount++;
		:}
		|
		error:l {: parser.report_error("Izvrsen oporavak do { u liniji "+lleft+" pri deklaraciji prosirenja natklase.",null); :}
		|
		/* epsilon */
		;
		
VarDeclList ::= VarDeclList VarDecl {:
					if (classDef && !methodDef) {
						parser.classFieldCount++;
					}
				:}
				|
				/* epsilon */
				;
				
ClassMethods ::= LBRACE MethodDeclList RBRACE
				|
				/* epsilon */
				;



MethodDeclList ::= MethodDeclList MethodDecl
					|
					/* epsilon */
					;

MethodDecl ::= ReturnType:retType IDENT:methName 
				{: 
					currentMethod = Tab.insert(Obj.Meth, methName, retType);
					Tab.openScope();
					currentLevel++;
					methodDef = true;
					parser.report_info("Obradjuje se funkcija na liniji "+methNameleft, null);
				 :}
				LPAREN FormalParams RPAREN VarDeclList LBRACE StatementList RBRACE {:
					methodDef = false;
					if (!classDef)
						parser.funcCount++;
					else
						parser.classMethodCount++;
					parser.statementBlocks++;
					
					if (!returnFound && retType != Tab.noType) {
						parser.report_error("Semanticka greska na liniji " +methNameleft+": funkcija "+methName+" nema return iskaz.", null);
					}
					returnFound = false;
					Tab.chainLocalSymbols(currentMethod);
					currentMethod = null;
					Tab.closeScope();
					currentLevel--;
				:}
				;

ReturnType ::= Type:retType
{:
	RESULT = retType;
:}
				|
				VOID
{:
	isVoid=true;
	RESULT = Tab.noType;
:}
				;

FormalParams ::= FormPars
				|
				/* epsilon */
				;

FormPars  ::=  FormPars COMMA Parameter
		     		|    
		     		Parameter
		     		;

Parameter  ::=  Type IDENT:varName
{:
	Obj temp = Tab.find(varName);
	if (temp.getLevel() == currentLevel) {
		parser.report_error(varName, varNameleft, "duplikat imena u formalnim parametrima funkcije");
	}
	else {
		Tab.insert(Obj.Var, varName, var_type);
		parser.report_info("Deklarisan parametar "+varName+" na liniji "+varNameleft, null);
	}
:}
	            |
	            Type IDENT:varName LSQUARE RSQUARE
{:
			Obj temp = Tab.find(varName);
			if (temp.getLevel() == currentLevel) {
				parser.report_error(varName, varNameleft, "duplikat imena u formalnim parametrima funkcije");
			}
			else {
				Tab.insert(Obj.Var, varName, new Struct(Struct.Array, var_type));
				parser.report_info("Deklarisan parametar "+varName+" na liniji "+varNameleft, null);
			}
:}
	            |
	            error:l {: parser.report_error("Izvrsen oporavak do , ili ) u liniji "+lleft+" pri deklaraciji formalnog parametra funkcije",null); :}
	            ;

StatementList ::= StatementList Statement
					|
					/* epsilon */
					;

Statement ::= Matched | Unmatched ;

 

Matched ::= Designator:dest EQUAL Expr:e SEMI
{:
	if (!e.assignableTo(dest.getType()) && dest.getType().getKind() != Struct.Array) {
		parser.report_error("Semanticka greska na liniji "+destleft+": izraz tipa "+e+" ne moze biti dodeljen tipu "+dest.getType(),null);
	}
	else if (!e.assignableTo(dest.getType().getElemType()) && dest.getType().getKind() == Struct.Array) {
		parser.report_error("Semanticka greska na liniji "+destleft+": izraz tipa "+e+" ne moze biti dodeljen tipu "+dest.getType().getElemType(),null);
	}
	if (dest.getKind() == Obj.Con) {
		parser.report_error(dest.getName(), destleft, "ne moze se menjati vrednost konstantnom objektu");
	}
:}
				|
			Designator DesignatorsFollowUp SEMI
				|
			Designator:func LPAREN ActParams RPAREN SEMI
{:
	if (Obj.Meth == func.getKind()) {
		parser.report_info("Pronadjen poziv funkcije "+func.getName()+" na liniji "+funcleft, null);
		RESULT = func.getType();
	}
	else {
		parser.report_error("Semanticka greska na liniji "+funcleft+": ime "+func.getName()+" nije funkcija.", null);
		RESULT = Tab.noType;
	}
:}
				|
			Designator LPAREN error:l RPAREN SEMI {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" pri zadavanju liste parametara u pozivu funkcije",null); :}
				|
			Designator LPAREN error:l SEMI {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" pri pozivu funkcije.",null); :}
				|
				Designator EQUAL error:l SEMI
					{: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" pri iskazu dodele vrednosti.",null); :}
				|
				RETURN Expr:t SEMI 
				{:
					returnFound = true;
					Struct currMethType = currentMethod.getType();
					if (!currMethType.compatibleWith(t)) {
						parser.report_error("Semanticka greska na liniji "+tleft+": tip izraza u return naredbi se ne slaze sa tipom povratne vrednosti funkcije "+currentMethod.getName(),null);
					}
					if (isVoid) {
						parser.report_error("Semanticka greska na liniji "+tleft+": metod ne sme imati return sa izrazom jer je deklarisan sa void",null);
					}
				:}
				|
				RETURN:dummy SEMI
				{:
					returnFound = true;
					if (!isVoid) {
						parser.report_error("Semnaticka greska u liniji "+dummyleft+": nedostaje return iskaz.", null);
					}
				:}
				|
				IF LPAREN Condition RPAREN Matched ELSE Matched
				|
				IF LPAREN error:l RPAREN Matched ELSE Matched {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" unutar izraza u if konstrukciji.",null); :}
				|
				WHILE LPAREN Condition RPAREN Matched
				|
				WHILE LPAREN error:l RPAREN Matched {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" unutar izraza u while konstrukciji.",null); :}
				|
				BREAK SEMI
				|
				READ LPAREN Designator RPAREN SEMI
				|
				PRINT LPAREN Expr OptNumbers RPAREN SEMI
				|
				LBRACE StatementList RBRACE  {:
						parser.statementBlocks++;
					:}
				;
				
OptNumbers ::= OptNumbers COMMA NUMBER
				|
				/* epsilon */
				;
				
ActParams ::= ActPars:params
{:
		//provera na broj argumenata!!!
		int i=0;
	    for (Obj obj:currentMethod.getLocalSymbols()) {
	    	if (actualParameters[i].getType() != obj.getType() || (obj.getType().getKind()==Struct.Array && actualParameters[i].getType().getElemType() != obj.getType().getElemType())) {
	    		parser.report_error(obj.getName(), paramsleft, "nekompatibilni tipovi stvarnih sa formalnim parametrima");
	    	}
	    	else {
	    		parser.report_info(obj.getName(), paramsleft, obj);
	    	}
	    	i++;
	    }
:}
				|
				/* epsilon */
				;
				
ActPars ::= ActPars COMMA Expr
			|
			Expr
			;
			
Condition ::= Condition OR CondTerm
				|
				CondTerm
				;
				
CondTerm ::= CondTerm AND CondFact
				|
				CondFact
				;
				
CondFact ::= CondFact Relop Expr
				|
				Expr
				;
				
Expr ::= Sign Term:te AddList:t
{:
	if (t==Tab.noType || (te.equals(t) && te==Tab.intType))
		RESULT = te;
	else {
		parser.report_error("Semanticka greska na liniji "+teleft+": nekompatibilni tipovu u izrazu za sabiranje", null);
		RESULT = Tab.noType;
	}
:} ;

Sign ::= MINUS | /* epsilon */ ;

AddList ::= AddList:te Addop Term:t
{:
	if (te==Tab.noType || (te.equals(t) && te==Tab.intType))
		RESULT = t;
	else {
		parser.report_error("Semanticka greska na liniji "+teleft+": nekompatibilni tipovu u izrazu za sabiranje 2", null);
		RESULT = Tab.noType;
	}
:}
			|
			/* epsilon */
{:
	RESULT = Tab.noType;
:}
			;
			
Term ::= Factor:te MulList:t
{:
	if (t==Tab.noType || (te.equals(t) && te==Tab.intType))
		RESULT = te;
	else {
		parser.report_error("Semanticka greska na liniji "+teleft+": nekompatibilni tipovu u izrazu za mnozenje 2", null);
		RESULT = Tab.noType;
	}
:} ;

MulList ::= MulList:te Mulop Factor:t
{:
	if (te==Tab.noType || (te.equals(t) && te==Tab.intType))
		RESULT = t;
	else {
		parser.report_error("Semanticka greska na liniji "+teleft+": nekompatibilni tipovu u izrazu za mnozenje", null);
		RESULT = Tab.noType;
	}
:}
			|
			/* epsilon */
{:
	RESULT = Tab.noType;
:}
			;
			
Factor ::= Designator:func LPAREN ActParams RPAREN
{:
	if (Obj.Meth == func.getKind()) {
		parser.report_info("Pronadjen poziv funkcije "+func.getName()+" na liniji "+funcleft, null);
		RESULT = func.getType();
	}
	else {
		parser.report_error("Semanticka greska na liniji "+funcleft+": ime "+func.getName()+" nije funkcija.", null);
		RESULT = Tab.noType;
	}
	
:}
			|
		   Designator:d {: RESULT = d.getType(); :}
			|
			NUMBER {: RESULT = Tab.intType; :}
			|
			CHARCONST
			|
			BOOLCONST
			|
			STRCONST
			|
			NEW Type {:
				parser.newStatementCount++;
			:}
			|
			NEW Type LSQUARE Expr RSQUARE
			|
			LPAREN Expr RPAREN
			;
				
DesignatorsFollowUp ::= 
						INC
						|
						DEC
						;
				
Unmatched ::= IF LPAREN Condition RPAREN Statement
			 |
			 IF LPAREN error:l RPAREN Statement {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" unutar izraza u if konstrukciji.",null); :}
			 | 
			 IF LPAREN Condition RPAREN Matched ELSE Unmatched
			 |
			 IF LPAREN error:l RPAREN Matched ELSE Unmatched {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" unutar izraza u if konstrukciji.",null); :}
			 |
			 WHILE LPAREN Condition RPAREN Unmatched
			 |
			 WHILE LPAREN error:l RPAREN Unmatched {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" unutar izraza u while konstrukciji.",null); :}
			 ;
					
Designator ::= IDENT:name
{:
	Obj obj = Tab.find(name);
	if (obj == Tab.noObj) {
		parser.report_error(name, nameleft, "nije deklarisano");
	}
	parser.report_info(name, nameleft, obj);
	RESULT = obj;
	curr_ident = obj;
:} IdentList;

IdentList ::= IdentList:il IdentRef:ir 
{: 
	if (ir != null)
		RESULT = ir;
	else
		RESULT = il;
:}
				|
				/* epsilon */ {: RESULT = Tab.noObj; :}
				;
				
IdentRef ::= DOT IDENT:ident
			{:
				if (curr_ident.getKind() == Struct.Class) {
					Obj obj = Tab.find(ident);
					if (obj == Tab.noObj) {
						parser.report_error("Semanticka greska na liniji "+identleft+": ime "+ident+" nije deklarisano.", null);
					}
					RESULT = obj;
					curr_ident = obj;
					
				}
				else {
					parser.report_error("Semanticka greska u liniji "+identleft+": "+curr_ident.getName()+" mora biti promenljiva klasnog tipa.",null);
				}
			:}
			|
			LSQUARE:dummy Expr RSQUARE
			{:
				 if (curr_ident.getType().getKind()!=Struct.Array) 
                              parser.report_error("Semanticka greska u liniji "+dummyleft+": Ocekivan niz na mestu identifikatora "+curr_ident.getName(),null);
			:}
			|
			LSQUARE error:l RSQUARE {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" pri indeksiranju niza.",null); :}
			;

Relop ::= IS_EQUAL
			|
			NOT_EQUAL
			|
			GT
			|
			GTE
			|
			LT
			|
			LTE
			;

Addop ::= PLUS
			|
			MINUS
			;
			
Mulop ::= TIMES
			|
			DIV
			|
			MOD
			;