package rs.ac.bg.etf.pp1.sv110059;

import java_cup.runtime.*;
import java.io.*;
import rs.etf.pp1.symboltable.*;
import rs.etf.pp1.symboltable.concepts.*;


parser code {:
	//promenljive za brojanje pojavljivanja odredjenih elemenata
	
	int globalCharVarCount = 0; //TODO: R40
	int globalArrayCount = 0; //R41
	int funcCount = 0; //R42
	int classCount = 0; //R43
	int statementBlocks = 0; //R44
	int funcCallsInMain = 0; //TODO: R45
	int newStatementCount = 0; //R46
	int classMethodCount = 0; //R47
	int classFieldCount = 0; //R48
	int classDerivationCount = 0; //R49

    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
    boolean greska;
     
   public void report_fatal_error(String message, Object   info) throws java.lang.Exception {
   	  greska=true;
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info)
    {
      greska=true;
      System.err.print(message);
      System.err.flush();
      if (info instanceof Symbol)
          System.err.println(" na liniji " + ((Symbol)info).left);
      else System.err.println("");
    }
    
    public void report_info(String message, Object info)
    {
      System.out.print(message);
      System.out.flush();
      if (info instanceof Symbol)
          System.out.println(" na liniji " + ((Symbol)info).left);
      else System.out.println("");
    }
    
    public void printCounts() {
    	System.out.println("Broj elemenata: ");
    	System.out.println("Deklaracije globalnih nizova - " + globalArrayCount);
    	System.out.println("Definicije funkcija u glavnom programu - " + funcCount);
    	System.out.println("Definicije unutrasnjih klasa - " + classCount);
    	System.out.println("Blokovi naredbi - " + statementBlocks);
    	System.out.println("Naredbe stvaranja objekta - " + newStatementCount);
    	System.out.println("Definicije metoda unutrasnjih klasa - " + classMethodCount);
    	System.out.println("Definicije polja unutrasnjih klasa - " + classFieldCount);
    	System.out.println("Izvodjenja klasa - " + classDerivationCount);
    }
    
    public static void main(String args[]) throws Exception {
        FileReader r = new FileReader(args[0]);
        Yylex skener = new Yylex(r);
        MJParser p = new MJParser(skener);
        Symbol s = p.parse();  //pocetak parsiranja
        Tab.dump();
        if (p.greska) 
        	System.out.println("Ulazni program ima gresaka!");
        else {
        	p.printCounts();
        	System.out.println("Parsiranje uspesno zavrseno!");
        }
    }
    
:}


action code {:

	boolean global = true;
	boolean classDef = false;
	boolean methodDef = false;
	Struct var_type=Tab.noType;
	Obj currentMethod = null;
	boolean returnFound = false;
	int currentLevel = -1;
	
:}

init with {:
	Tab.init();
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		System.out.println(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROGRAM, LBRACE, RBRACE, SEMI, LPAREN, RPAREN, COMMA, PRINT, RETURN, PLUS, EQUAL, VOID ;
terminal EXTENDS, GT, GTE, LT, LTE, NEW, DIV, MOD, MINUS, NOT_EQUAL, IS_EQUAL, CONST, AND, LSQUARE, RSQUARE, OR, TIMES ;
terminal BREAK, INC, DEC, WHILE, CLASS, CHARCONST, BOOLCONST, STRCONST, ELSE, IF, READ, DOT ;
terminal Integer NUMBER ;
terminal String IDENT ;

non terminal Program, VarDeclList, MethodDeclList, VarDecl, MethodDecl, GlobalVarDecl, GlobalVarList ;
non terminal FormPars, Addop ;
non terminal StatementList, Statement ;
non terminal Unmatched, Matched ;
non terminal Rhs, DeclarationList, DeclarationPart, ConstDecl, VarList, ConstPart ;
non terminal ClassDecl, Ext, ClassMethods, Parameter, FormalParams, IdentList, IdentRef ;
non terminal DesignatorsFollowUp, Condition, OptNumbers, ActPars, CondTerm, CondFact, Relop, Sign, Mulop, ActParams ;
non terminal String Var;

non terminal Obj ProgName, Designator;
non terminal Struct Type, ReturnType, Term, Expr, Factor, AddList, MulList;

Program ::= PROGRAM ProgName:p DeclarationList LBRACE {:
						global = false;
					:} MethodDeclList RBRACE
{:
	Tab.chainLocalSymbols(p);
	Tab.closeScope();
	currentLevel--;
:};

ProgName ::= IDENT:pName
{:
	RESULT = Tab.insert(Obj.Prog, pName, Tab.noType);
	Tab.openScope();
	currentLevel++;
:};

DeclarationList	::=  DeclarationList DeclarationPart
					|
					/* epsilon */
					;

DeclarationPart	::=  ConstDecl
					|    
					GlobalVarDecl
					|
					ClassDecl
					;

ConstDecl ::= CONST Type ConstPart SEMI
				|
			CONST error:l SEMI {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" pri definiciji globalne promenljive tipa konstante",null); :}
				 ;
				 
ConstPart ::= IDENT EQUAL Rhs
				|
				IDENT error
				|
			  ConstPart COMMA IDENT EQUAL Rhs
			  //	|
			 // 	error COMMA IDENT EQUAL Rhs {: System.err.println("Uspesan oporavak od greske pri definiciji globalne promenljive konst2."); :}
				;
				
Rhs ::= NUMBER
			|
			CHARCONST
			|
			BOOLCONST
			|
			STRCONST
			;

GlobalVarDecl ::= Type GlobalVarList SEMI
				|
			Type:varType error:l SEMI {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" pri definiciji globalne promenljive",null); :}
			;

VarDecl ::= Type VarList SEMI
				|
			Type error:l SEMI {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" pri definiciji lokalne promenljive/polja unutrasnje klase",null); :}
				|
			Type error:l  {: parser.report_error("Izvrsen oporavak do { u liniji "+lleft+" pri definiciji lokalne promenljive/polja unutrasnje klase",null); :}
				;

GlobalVarList ::= GlobalVarList COMMA Var:varName
{:
	Obj temp = Tab.find(varName);
	if (temp.getLevel() == currentLevel) {
		parser.report_error("Semanticka greska na liniji "+varNameleft+": redefinicija promenljive "+varName, null);
	}
	else {
		Tab.insert(Obj.Var, varName, var_type);
		parser.report_info("Deklarisana promenljiva "+varName+" na liniji "+varNameleft, null);
	}
:}
					|
					Var:varName
{:
	Obj temp = Tab.find(varName);
	if (temp.getLevel() == currentLevel) {
		parser.report_error("Semanticka greska na liniji "+varNameleft+": redefinicija globalne promenljive "+varName, null);
	}
	else {
		Tab.insert(Obj.Var, varName, var_type);
		parser.report_info("Deklarisana globalna promenljiva "+varName+" na liniji "+varNameleft, null);
	}
:}
					| 
					error:l COMMA Var:varName 
{: 
Tab.insert(Obj.Var, varName, var_type); parser.report_error("Izvrsen oporavak do , u liniji "+lleft+" pri definiciji globalne promenljive",null); 
:}
					;

VarList ::= VarList COMMA Var:varName
{:	
	Obj temp = Tab.find(varName);
	if (temp.getLevel() == currentLevel) {
		parser.report_error("Semanticka greska na liniji "+varNameleft+": redefinicija promenljive "+varName, null);
	}
	else {
		Tab.insert(Obj.Var, varName, var_type);
		parser.report_info("Deklarisana promenljiva "+varName+" na liniji "+varNameleft, null);
	}
:}
					|
					Var:varName
{:
	Obj temp = Tab.find(varName);
	if (temp.getLevel() == currentLevel) {
		parser.report_error("Semanticka greska na liniji "+varNameleft+": redefinicija promenljive "+varName, null);
	}
	else {
		Tab.insert(Obj.Var, varName, var_type);
		parser.report_info("Deklarisana promenljiva "+varName+" na liniji "+varNameleft, null);
	}
:}
					;
					
Var ::= IDENT:varName
{:
	RESULT = varName;
:}
		|
		IDENT:varName LSQUARE RSQUARE {:
			if (global && !classDef)
				parser.globalArrayCount++;
			RESULT = varName;
		:}
		;

Type ::= IDENT:typeName
{:
	
	Obj typeNode = Tab.find(typeName);
	if (typeNode == Tab.noObj) {
		parser.report_error("Semanticka greska na liniji "+typeNameleft+ ": Nije pronadjen tip " + typeName + " u tabeli simbola.", null);
		var_type = RESULT = Tab.noType;
	}
	else {
		if (Obj.Type == typeNode.getKind()) {
			var_type = RESULT = typeNode.getType();
		}
		else {
			parser.report_error("Semanticka greska na liniji "+typeNameleft+ ": Ime " + typeName + " ne predstavlja tip.", null);
			var_type = RESULT = Tab.noType;
		}
	}
:};

ClassDecl ::= CLASS IDENT Ext LBRACE {:
					classDef = true;
				:} VarDeclList ClassMethods RBRACE {:
					parser.classCount++;
					classDef = false;
				:}
				;

Ext ::= EXTENDS Type {:
			parser.classDerivationCount++;
		:}
		|
		error:l {: parser.report_error("Izvrsen oporavak do { u liniji "+lleft+" pri deklaraciji prosirenja natklase.",null); :}
		|
		/* epsilon */
		;
		
VarDeclList ::= VarDeclList VarDecl {:
					if (classDef && !methodDef) {
						parser.classFieldCount++;
					}
				:}
				|
				/* epsilon */
				;
				
ClassMethods ::= LBRACE MethodDeclList RBRACE
				|
				/* epsilon */
				;



MethodDeclList ::= MethodDeclList MethodDecl
					|
					/* epsilon */
					;

MethodDecl ::= ReturnType:retType IDENT:methName 
				{: 
					currentMethod = Tab.insert(Obj.Meth, methName, retType);
					Tab.openScope();
					currentLevel++;
					methodDef = true;
					parser.report_info("Obradjuje se funkcija na liniji "+methNameleft, null);
				 :}
				LPAREN FormalParams RPAREN VarDeclList LBRACE StatementList RBRACE {:
					methodDef = false;
					if (!classDef)
						parser.funcCount++;
					else
						parser.classMethodCount++;
					parser.statementBlocks++;
					
					if (!returnFound && retType != Tab.noType) {
						parser.report_error("Semanticka greska na liniji " +methNameleft+": funkcija "+methName+" nema return iskaz.", null);
					}
					returnFound = false;
					currentMethod = null;
					Tab.chainLocalSymbols(currentMethod);
					Tab.closeScope();
					currentLevel--;
				:}
				;

ReturnType ::= Type
				|
				VOID
				;

FormalParams ::= FormPars
				|
				/* epsilon */
				;

FormPars  ::=  FormPars COMMA Parameter
		     		|    
		     		Parameter
		     		;

Parameter  ::=  Type IDENT
	            |
	            Type IDENT LSQUARE RSQUARE
	            |
	            error:l {: parser.report_error("Izvrsen oporavak do , ili ) u liniji "+lleft+" pri deklaraciji formalnog parametra funkcije",null); :}
	            ;

StatementList ::= StatementList Statement
					|
					/* epsilon */
					;

Statement ::= Matched | Unmatched ;

 

Matched ::= Designator:dest EQUAL Expr:e SEMI
{:
	if (!e.assignableTo(dest.getType())) {
		parser.report_error("Semanticka greska na liniji "+destleft+": izraz tipa "+e+" ne moze biti dodeljen tipu "+dest.getType(),null);
	}
:}
				|
			Designator DesignatorsFollowUp SEMI
				|
			Designator:func LPAREN ActParams RPAREN SEMI
{:
	if (Obj.Meth == func.getKind()) {
		parser.report_info("Pronadjen poziv funkcije "+func.getName()+" na liniji "+funcleft, null);
		RESULT = func.getType();
	}
	else {
		parser.report_error("Semanticka greska na liniji "+funcleft+": ime "+func.getName()+" nije funkcija.", null);
		RESULT = Tab.noType;
	}
:}
				|
			Designator LPAREN error:l RPAREN SEMI {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" pri zadavanju liste parametara u pozivu funkcije",null); :}
				|
			Designator LPAREN error:l SEMI {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" pri pozivu funkcije.",null); :}
				|
				Designator EQUAL error:l SEMI
					{: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" pri iskazu dodele vrednosti.",null); :}
				|
				RETURN Expr:t SEMI 
				{:
					returnFound = true;
					Struct currMethType = currentMethod.getType();
					if (!currMethType.compatibleWith(t)) {
						parser.report_error("Semanticka greska na liniji "+tleft+": tip izraza u return naredbi se ne slaze sa tipom povratne vrednosti funkcije "+currentMethod.getName(),null);
					}
				:}
				|
				RETURN SEMI
				|
				IF LPAREN Condition RPAREN Matched ELSE Matched
				|
				IF LPAREN error:l RPAREN Matched ELSE Matched {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" unutar izraza u if konstrukciji.",null); :}
				|
				WHILE LPAREN Condition RPAREN Matched
				|
				WHILE LPAREN error:l RPAREN Matched {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" unutar izraza u while konstrukciji.",null); :}
				|
				BREAK SEMI
				|
				READ LPAREN Designator RPAREN SEMI
				|
				PRINT LPAREN Expr OptNumbers RPAREN SEMI
				|
				LBRACE StatementList RBRACE  {:
						parser.statementBlocks++;
					:}
				;
				
OptNumbers ::= OptNumbers COMMA NUMBER
				|
				/* epsilon */
				;
				
ActParams ::= ActPars
				|
				/* epsilon */
				;
				
ActPars ::= ActPars COMMA Expr
			|
			Expr
			;
			
Condition ::= Condition OR CondTerm
				|
				CondTerm
				;
				
CondTerm ::= CondTerm AND CondFact
				|
				CondFact
				;
				
CondFact ::= CondFact Relop Expr
				|
				Expr
				;
				
Expr ::= Sign Term:te AddList:t
{:
	if (te.equals(t) && te==Tab.intType)
		RESULT = te;
	else {
		parser.report_error("Semanticka greska na liniji "+teleft+": nekompatibilni tipovu u izrazu za sabiranje", null);
		RESULT = Tab.noType;
	}
:} ;

Sign ::= MINUS | /* epsilon */ ;

AddList ::= AddList Addop Term:t
{:
	//semanticka provera kompatibilnosti tipova? epsilon smena?
	RESULT = t;
:}
			|
			/* epsilon */
			;
			
Term ::= Factor:te MulList:t
{:
	//uporedi te i t tipove - semanticka provera
	RESULT = te;
:} ;

MulList ::= MulList Mulop Factor:t
{:
	//semanticka provera kompatibilnosti tipova? epsilon smena?
	RESULT = t;
:}
			|
			/* epsilon */
			;
			
Factor ::= Designator:func LPAREN ActParams RPAREN
{:
	if (Obj.Meth == func.getKind()) {
		parser.report_info("Pronadjen poziv funkcije "+func.getName()+" na liniji "+funcleft, null);
		RESULT = func.getType();
	}
	else {
		parser.report_error("Semanticka greska na liniji "+funcleft+": ime "+func.getName()+" nije funkcija.", null);
		RESULT = Tab.noType;
	}
	
:}
			|
		   Designator:d {: RESULT = d.getType(); :}
			|
			NUMBER {: RESULT = Tab.intType; :}
			|
			CHARCONST
			|
			BOOLCONST
			|
			STRCONST
			|
			NEW Type {:
				parser.newStatementCount++;
			:}
			|
			NEW Type LSQUARE Expr RSQUARE
			|
			LPAREN Expr RPAREN
			;
				
DesignatorsFollowUp ::= 
						INC
						|
						DEC
						;
				
Unmatched ::= IF LPAREN Condition RPAREN Statement
			 |
			 IF LPAREN error:l RPAREN Statement {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" unutar izraza u if konstrukciji.",null); :}
			 | 
			 IF LPAREN Condition RPAREN Matched ELSE Unmatched
			 |
			 IF LPAREN error:l RPAREN Matched ELSE Unmatched {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" unutar izraza u if konstrukciji.",null); :}
			 |
			 WHILE LPAREN Condition RPAREN Unmatched
			 |
			 WHILE LPAREN error:l RPAREN Unmatched {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" unutar izraza u while konstrukciji.",null); :}
			 ;
					
Designator ::= IDENT:name
{:
	Obj obj = Tab.find(name);
	if (obj == Tab.noObj) {
		parser.report_error("Semanticka greska na liniji "+nameleft+": ime "+name+" nije deklarisano.", null);
	}
	RESULT = obj;
:} IdentList;

IdentList ::= IdentList IdentRef
				|
				/* epsilon */
				;
				
IdentRef ::= DOT IDENT:ident
			|
			LSQUARE Expr RSQUARE
			|
			LSQUARE error:l RSQUARE {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" pri indeksiranju niza.",null); :}
			;

Relop ::= IS_EQUAL
			|
			NOT_EQUAL
			|
			GT
			|
			GTE
			|
			LT
			|
			LTE
			;

Addop ::= PLUS
			|
			MINUS
			;
			
Mulop ::= TIMES
			|
			DIV
			|
			MOD
			;