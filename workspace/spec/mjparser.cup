package rs.ac.bg.etf.pp1.sv110059;

import java_cup.runtime.*;
import java.io.*;
import rs.etf.pp1.symboltable.*;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.symboltable.visitors.*;
import java.util.Collection;
import rs.ac.bg.etf.pp1.sv110059.util.*;


parser code {:
	//promenljive za brojanje pojavljivanja odredjenih elemenata
	
	int globalCharVarCount = 0; //TODO: R40
	int globalArrayCount = 0; //R41
	int funcCount = 0; //R42
	int classCount = 0; //R43
	int statementBlocks = 0; //R44
	int funcCallsInMain = 0; //TODO: R45
	int newStatementCount = 0; //R46
	int classMethodCount = 0; //R47
	int classFieldCount = 0; //R48
	int classDerivationCount = 0; //R49

    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
    boolean greska;
     
   public void report_fatal_error(String message, Object   info) throws java.lang.Exception {
   	  greska=true;
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info)
    {
      greska=true;
      System.err.print(message);
      System.err.flush();
      if (info instanceof Symbol)
          System.err.println(" na liniji " + ((Symbol)info).left);
      else System.err.println("");
    }
    
    public void report_info(String message, Object info)
    {
      System.out.print(message);
      System.out.flush();
      if (info instanceof Symbol)
          System.out.println(" na liniji " + ((Symbol)info).left);
      else System.out.println("");
    }
   
   	MyVisitor dstv = new MyVisitor();
   	
   	public void report_error(String symName, int line, String msg) {
   	  greska=true;
      System.err.print("Greska na "+line+"("+symName+"), "+msg);
      System.err.flush();
      System.err.println("");
   	}
   	
    public void report_info(String symName, int line, Obj obj) {
    	  dstv.visitObjNode(obj);
    	  System.out.print("Pretraga na "+line+"("+symName+"), nadjeno "+dstv.getOutput());
    	  dstv.flush();
	      System.out.flush();
	      System.out.println("");
    }
    
    
    public void printCounts() {
    	System.out.println("Broj elemenata: ");
    	System.out.println("Deklaracije globalnih nizova - " + globalArrayCount);
    	System.out.println("Definicije funkcija u glavnom programu - " + funcCount);
    	System.out.println("Definicije unutrasnjih klasa - " + classCount);
    	System.out.println("Blokovi naredbi - " + statementBlocks);
    	System.out.println("Naredbe stvaranja objekta - " + newStatementCount);
    	System.out.println("Definicije metoda unutrasnjih klasa - " + classMethodCount);
    	System.out.println("Definicije polja unutrasnjih klasa - " + classFieldCount);
    	System.out.println("Izvodjenja klasa - " + classDerivationCount);
    }
    
    public static void main(String args[]) throws Exception {
        FileReader r = new FileReader(args[0]);
        Yylex skener = new Yylex(r);
        MJParser p = new MJParser(skener);
       // Symbol s = p.debug_parse();  //pocetak parsiranja
       Symbol s = p.parse();
       
        if (p.greska) {
        	 Tab.dump();
        	System.out.println("Ulazni program ima gresaka!");
        }
        else {
        	System.out.println("==================SINTAKSNA ANALIZA====================");
        	p.printCounts();
        	Tab.dump();
        	System.out.println("Parsiranje uspesno zavrseno!");
        }
        
    }

    String getTypeName(Struct t) {
    	StringBuilder output = new StringBuilder();
    	switch (t.getKind()) {
		case Struct.None:
			output.append("notype");
			break;
		case Struct.Int:
			output.append("int");
			break;
		case Struct.Char:
			output.append("char");
			break;
		case Struct.Array:
			output.append("Arr of ");
			
			switch (t.getElemType().getKind()) {
			case Struct.None:
				output.append("notype");
				break;
			case Struct.Int:
				output.append("int");
				break;
			case Struct.Char:
				output.append("char");
				break;
			case Struct.Class:
				output.append("Class");
				break;
			}
			break;
		case Struct.Class:
			output.append("Class");
			break;
		}
		return output.toString();
    }
    
:}


action code {:

	boolean global = true;
	boolean classDef = false;
	boolean methodDef = false;
	Struct var_type=Tab.noType;
	Obj currentMethod = null;
	boolean returnFound = false;
	int currentLevel = -1;
	boolean isVoid=false;
	Obj curr_ident = null;
	boolean designatorIsArrElem = false;
	boolean insideWhile = false;
	Obj currentDesignator = null;
	Obj functionDesignator = null;
	int numOfActPars = 0;
	int currentMethodParams = 0;
	boolean lockFunctionDesignator = false;
	Obj previosDesignator = null;

:}

init with {:
	Tab.init();
	System.out.println("==================SEMANTICKA OBRADA====================");
	Struct boolType = new Struct(Struct.Bool);
    Tab.insert(Obj.Type, "bool", boolType);
    Struct stringType = new Struct(Struct.Array, Tab.charType);
    Tab.insert(Obj.Type, "string", stringType);
	
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	return s;
:}

terminal PROGRAM, LBRACE, RBRACE, SEMI, LPAREN, RPAREN, COMMA, PRINT, RETURN, PLUS, EQUAL, VOID ;
terminal EXTENDS, GT, GTE, LT, LTE, NEW, DIV, MOD, MINUS, NOT_EQUAL, IS_EQUAL, CONST, AND, LSQUARE, RSQUARE, OR, TIMES ;
terminal BREAK, INC, DEC, WHILE, CLASS, CHARCONST, BOOLCONST, STRCONST, ELSE, IF, READ, DOT ;
terminal Integer NUMBER ;
terminal String IDENT ;

non terminal Program, VarDeclList, MethodDeclList, VarDecl, MethodDecl, GlobalVarDecl, GlobalVarList ;
non terminal FormPars, Var ;
non terminal StatementList, Statement, ActPar ;
non terminal Unmatched, Matched, WhileLoop ;
non terminal DeclarationList, DeclarationPart, ConstDecl, VarList, ConstPart ;
non terminal ClassDecl, Ext, ClassMethods, Parameter, FormalParams, IdentList, IdentRef ;
non terminal DesignatorsFollowUp, Condition, OptNumbers, ActPars, CondTerm, CondFact, Sign, Mulop, ActParams ;
//non terminal String Var, ConstVar;
non terminal Integer Relop, Addop;
non terminal Obj ProgName, Designator, ConstVar;
non terminal Struct Type, ReturnType, Term, Expr, Factor, AddList, MulList, Rhs;

Program ::= PROGRAM ProgName:p DeclarationList LBRACE {:
						global = false;
					:} MethodDeclList RBRACE
{:
	
	Obj myMain = Tab.find("main");
	if (myMain==Tab.noObj) {
		parser.report_error("Greska : ulazni fajl ne sadrzi main metodu", null);
	}
	Tab.chainLocalSymbols(p);
	Tab.closeScope();
	currentLevel--;
	
:};

ProgName ::= IDENT:pName
{:
	RESULT = Tab.insert(Obj.Prog, pName, Tab.noType);
	Tab.openScope();
	currentLevel++;
:};

DeclarationList	::=  DeclarationList DeclarationPart
					|
					/* epsilon */
					;

DeclarationPart	::=  ConstDecl
					|    
					GlobalVarDecl
					|
					ClassDecl
					;

ConstDecl ::= CONST Type ConstPart SEMI
				|
			CONST error:l SEMI {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" pri definiciji globalne promenljive tipa konstante",null); :}
				 ;
				 
ConstPart ::= ConstVar:dest EQUAL Rhs:e
{:
	if (!e.assignableTo(dest.getType()) && dest.getType().getKind() != Struct.Array) {
		parser.report_error("Semanticka greska na liniji "+destleft+": izraz tipa "+parser.getTypeName(e)+" ne moze biti dodeljen tipu "+parser.getTypeName(dest.getType()),null);
	}
	else if (!e.assignableTo(dest.getType().getElemType()) && dest.getType().getKind() == Struct.Array) {
		parser.report_error("Semanticka greska na liniji "+destleft+": izraz tipa "+parser.getTypeName(e)+" ne moze biti dodeljen tipu "+parser.getTypeName(dest.getType()),null);
	}
:}
				|
				ConstVar error:l
{:
	parser.report_error("Izvrsen oporavak do ; u linij "+lleft+" pri definiciji konstante.", null);
:}
				|
			  ConstPart COMMA ConstVar:dest EQUAL Rhs:e
{:
	if (!e.assignableTo(dest.getType()) && dest.getType().getKind() != Struct.Array) {
		parser.report_error("Semanticka greska na liniji "+destleft+": izraz tipa "+parser.getTypeName(e)+" ne moze biti dodeljen tipu "+parser.getTypeName(dest.getType().getElemType()),null);
	}
	else if (!e.assignableTo(dest.getType().getElemType()) && dest.getType().getKind() == Struct.Array) {
		parser.report_error("Semanticka greska na liniji "+destleft+": izraz tipa "+parser.getTypeName(e)+" ne moze biti dodeljen tipu "+parser.getTypeName(dest.getType().getElemType()),null);
	}
:}

			  //	|
			 // 	error COMMA IDENT EQUAL Rhs {: parser.report_error("Uspesan oporavak od greske pri definiciji globalne promenljive konst2.", null); :}
				;

ConstVar ::= IDENT:varName
{:
	Obj temp = Tab.find(varName);
	if (temp.getLevel() == currentLevel) {
		parser.report_error("Semanticka greska na liniji "+varNameleft+": redefinicija promenljive "+varName, null);
		RESULT = Tab.noObj;
	}
	else {
		Obj obj = Tab.insert(Obj.Con, varName, var_type);
		parser.report_info("Deklarisana promenljiva "+varName+" na liniji "+varNameleft, null);
		RESULT = obj;
	}
:}
;
		
Rhs ::= NUMBER {: RESULT = Tab.intType; :}
			|
			CHARCONST {: RESULT = Tab.charType; :}
			|
			BOOLCONST {: RESULT = Tab.find("bool").getType(); :}
			|
			STRCONST {: RESULT = Tab.find("string").getType(); :}
			;

GlobalVarDecl ::= Type GlobalVarList SEMI
				|
			Type:varType error:l SEMI {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" pri definiciji globalne promenljive",null); :}
			;

VarDecl ::= Type VarList SEMI
				|
			Type error:l SEMI {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" pri definiciji lokalne promenljive/polja unutrasnje klase",null); :}
				|
			Type error:l  {: parser.report_error("Izvrsen oporavak do { u liniji "+lleft+" pri definiciji lokalne promenljive/polja unutrasnje klase",null); :}
				;

GlobalVarList ::= GlobalVarList COMMA Var
					|
					Var:varName
					| 
					error:l COMMA Var 
					;

VarList ::= VarList COMMA Var
					|
					Var
					;
					
Var ::= IDENT:varName
{:
	Obj temp = Tab.find(varName);
	if (temp.getLevel() == currentLevel) {
		parser.report_error("Semanticka greska na liniji "+varNameleft+": redefinicija promenljive "+varName, null);
	}
	else {
		Tab.insert(Obj.Var, varName, var_type);
		parser.report_info("Deklarisana promenljiva "+varName+" na liniji "+varNameleft, null);
	}
:}
		|
		IDENT:varName LSQUARE RSQUARE 
{:
			if (global && !classDef)
				parser.globalArrayCount++;

			Obj temp = Tab.find(varName);
			if (temp.getLevel() == currentLevel) {
				parser.report_error("Semanticka greska na liniji "+varNameleft+": redefinicija promenljive "+varName, null);
			}
			else {
				Tab.insert(Obj.Var, varName, new Struct(Struct.Array, var_type));
				parser.report_info("Deklarisana promenljiva "+varName+" na liniji "+varNameleft, null);
			}
:}
		;

Type ::= IDENT:typeName
{:
	
	Obj typeNode = Tab.find(typeName);
	if (typeNode == Tab.noObj) {
		parser.report_error("Semanticka greska na liniji "+typeNameleft+ ": Nije pronadjen tip " + typeName + " u tabeli simbola.", null);
		var_type = RESULT = Tab.noType;
	}
	else {
		if (Obj.Type == typeNode.getKind()) {
			var_type = RESULT = typeNode.getType();
		}
		else {
			parser.report_error("Semanticka greska na liniji "+typeNameleft+ ": Ime " + typeName + " ne predstavlja tip.", null);
			var_type = RESULT = Tab.noType;
		}
	}
:};

ClassDecl ::= CLASS IDENT:name Ext LBRACE {:
					classDef = true;
					Obj tmp = Tab.find(name);
					if (tmp != Tab.noObj) {
						parser.report_error(name, nameleft, "duplikat naziva klase");
					}
					else {
						Tab.insert(Obj.Type, name, Tab.nullType);
					}
					
				:} VarDeclList ClassMethods RBRACE {:
					parser.classCount++;
					classDef = false;
				:}
				;

Ext ::= EXTENDS Type:t {:
			parser.classDerivationCount++;
			if (t.getKind() != Struct.Class) {
				parser.report_error(parser.getTypeName(t), tleft, "nije klasnog tipa");
			}
		:}
		|
		error:l {: parser.report_error("Izvrsen oporavak do { u liniji "+lleft+" pri deklaraciji prosirenja natklase.",null); :}
		|
		/* epsilon */
		;
		
VarDeclList ::= VarDeclList VarDecl {:
					if (classDef && !methodDef) {
						parser.classFieldCount++;
					}
				:}
				|
				/* epsilon */
				;
				
ClassMethods ::= LBRACE MethodDeclList RBRACE
				|
				/* epsilon */
				;



MethodDeclList ::= MethodDeclList MethodDecl
					|
					/* epsilon */
					;

MethodDecl ::= ReturnType:retType IDENT:methName 
				{: 
					if (Tab.find(methName) != Tab.noObj) {
						parser.report_error(methName, methNameleft, "duplikat imena u tabeli simbola");
					}
					currentMethod = Tab.insert(Obj.Meth, methName, retType);
					currentMethodParams = 0;
					Tab.openScope();
					currentLevel++;
					methodDef = true;
					parser.report_info("Obradjuje se funkcija na liniji "+methNameleft, null);
					if (currentMethod.getName().equals("main") && retType != Tab.noType) {
						parser.report_error("Main funkcija mora imati povratni tip void", null);
					}
				 :}
				LPAREN FormalParams RPAREN VarDeclList LBRACE StatementList RBRACE {:
					methodDef = false;
					if (!classDef)
						parser.funcCount++;
					else
						parser.classMethodCount++;
					parser.statementBlocks++;
					
					if (!returnFound && retType != Tab.noType) {
						parser.report_error("Semanticka greska na liniji " +methNameleft+": funkcija "+methName+" nema return iskaz.", null);
					}
					returnFound = false;
					Tab.chainLocalSymbols(currentMethod);
					lockFunctionDesignator = false;
					currentMethod.setFpPos(currentMethodParams);
					currentMethod = null;
					Tab.closeScope();
					currentLevel--;
				:}
				;

ReturnType ::= Type:retType
{:
	RESULT = retType;
:}
				|
				VOID
{:
	isVoid=true;
	RESULT = Tab.noType;
:}
				;

FormalParams ::= FormPars 
{:
	if (currentMethod.getName().equals("main")) {
		parser.report_error("Main funkcija ne sme sadrzati argumente",null);
	}
:}
				|
				/* epsilon */
				;

FormPars  ::=  FormPars COMMA Parameter
		     		|    
		     		Parameter
		     		;

Parameter  ::=  Type IDENT:varName
{:
	Obj temp = Tab.find(varName);
	if (temp.getLevel() == currentLevel) {
		parser.report_error(varName, varNameleft, "duplikat imena u formalnim parametrima funkcije");
	}
	else {
		Tab.insert(Obj.Var, varName, var_type);
		parser.report_info("Deklarisan parametar "+varName+" na liniji "+varNameleft, null);
	}
	currentMethodParams++;
:}
	            |
	            Type IDENT:varName LSQUARE RSQUARE
{:
			Obj temp = Tab.find(varName);
			if (temp.getLevel() == currentLevel) {
				parser.report_error(varName, varNameleft, "duplikat imena u formalnim parametrima funkcije");
			}
			else {
				Tab.insert(Obj.Var, varName, new Struct(Struct.Array, var_type));
				parser.report_info("Deklarisan parametar "+varName+" na liniji "+varNameleft, null);
			}
:}
	            |
	            error:l {: parser.report_error("Izvrsen oporavak do , ili ) u liniji "+lleft+" pri deklaraciji formalnog parametra funkcije",null); :}
	            ;

StatementList ::= StatementList Statement
					|
					/* epsilon */
					;

Statement ::= Matched | Unmatched ;

 

Matched ::= Designator:dest EQUAL Expr:e SEMI
{:
	if (!e.assignableTo(dest.getType()) && dest.getType().getKind() != Struct.Array) {
		parser.report_error("Semanticka greska na liniji "+destleft+": izraz tipa "+parser.getTypeName(e)+" ne moze biti dodeljen tipu "+parser.getTypeName(dest.getType()),null);
	}
	else if (!e.assignableTo(dest.getType().getElemType()) && dest.getType().getKind() == Struct.Array) {
		parser.report_error("Semanticka greska na liniji "+destleft+": izraz tipa "+parser.getTypeName(e)+" ne moze biti dodeljen tipu "+parser.getTypeName(dest.getType()),null);
	}
	if (dest.getKind() == Obj.Con) {
		parser.report_error(parser.getTypeName(dest.getType()), destleft, "ne moze se menjati vrednost konstantnom objektu");
	}
	if (dest.getKind() != Obj.Var && dest.getKind() != Obj.Fld) {
		parser.report_error(parser.getTypeName(dest.getType()), destleft, "designator mora biti promenljiva, element niza ili polje unutar objekta");
	}
	if (dest.getType().getKind()==Struct.Array && !designatorIsArrElem) {
		parser.report_error(parser.getTypeName(dest.getType()), destleft, "designator mora biti promenljiva, element niza ili polje unutar objekta");
	}
:}
				|
			Designator:dest DesignatorsFollowUp SEMI
{:
	if (dest.getType() != Tab.intType) {
		parser.report_error(parser.getTypeName(dest.getType()), destleft, "designator mora biti tipa int u postfiksnom inkrementu i dekrementu");
	}
	if (dest.getKind() == Obj.Con) {
		parser.report_error(parser.getTypeName(dest.getType()), destleft, "ne moze se menjati vrednost konstantnom objektu");
	}
	if (dest.getKind() != Obj.Var && dest.getKind() != Obj.Fld) {
		parser.report_error(parser.getTypeName(dest.getType()), destleft, "designatormora biti promenljiva, element niza ili polje unutar objekta");
	}
	if (dest.getType().getKind()==Struct.Array && !designatorIsArrElem) {
		parser.report_error(parser.getTypeName(dest.getType()), destleft, "designator mora biti promenljiva, element niza ili polje unutar objekta");
	}
:}
				|
			Designator:func LPAREN ActParams RPAREN SEMI
{:
	if (Obj.Meth == func.getKind()) {
		parser.report_info("Pronadjen poziv funkcije "+func.getName()+" na liniji "+funcleft, null);
		RESULT = func.getType();
	}
	else {
		parser.report_error("Semanticka greska na liniji "+funcleft+": ime "+func.getName()+" nije funkcija.", null);
		RESULT = Tab.noType;
	}
:}
				|
			Designator LPAREN error:l RPAREN SEMI {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" pri zadavanju liste parametara u pozivu funkcije",null); :}
				|
			Designator LPAREN error:l SEMI {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" pri pozivu funkcije.",null); :}
				|
				Designator EQUAL error:l SEMI
					{: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" pri iskazu dodele vrednosti.",null); :}
				|
				RETURN Expr:t SEMI 
				{:
					returnFound = true;
					Struct currMethType = currentMethod.getType();
					if (!currMethType.compatibleWith(t)) {
						parser.report_error("Semanticka greska na liniji "+tleft+": tip izraza u return naredbi se ne slaze sa tipom povratne vrednosti funkcije "+currentMethod.getName(),null);
					}
					if (isVoid) {
						parser.report_error("Semanticka greska na liniji "+tleft+": metod ne sme imati return sa izrazom jer je deklarisan sa void",null);
					}
				:}
				|
				RETURN:dummy SEMI
				{:
					returnFound = true;
					if (!isVoid) {
						parser.report_error("Semnaticka greska u liniji "+dummyleft+": nedostaje return iskaz.", null);
					}
				:}
				|
				IF LPAREN Condition RPAREN Matched ELSE Matched
				|
				IF LPAREN error:l RPAREN Matched ELSE Matched {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" unutar izraza u if konstrukciji.",null); :}
				|
				WhileLoop  LPAREN Condition RPAREN Matched {: insideWhile = false; :}
				|
				WhileLoop LPAREN error:l RPAREN Matched {: insideWhile = false; parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" unutar izraza u while konstrukciji.",null); :}
				|
				BREAK:dummy SEMI
				{:
					if (!insideWhile) {
						parser.report_error("break", dummyleft, "moze se koristiti samo u while petlji");
					}
					:}
				|
				READ LPAREN Designator:dest RPAREN SEMI
{:
	if (dest.getType() != Tab.intType && dest.getType() != Tab.charType && dest.getType() != Tab.find("bool").getType() && dest.getType() != Tab.find("string").getType()) {
		parser.report_error(dest.getName(), destleft, "u pozivu read(Designator) designator mora biti tipa int, char, bool ili string");
	}
	if (dest.getKind() != Obj.Var && dest.getKind() != Obj.Fld) {
		parser.report_error(parser.getTypeName(dest.getType()), destleft, "designator mora biti promenljiva, element niza ili polje unutar objekta");
	}
	if (dest.getType().getKind()==Struct.Array && !designatorIsArrElem) {
		parser.report_error(parser.getTypeName(dest.getType()), destleft, "designator mora biti promenljiva, element niza ili polje unutar objekta");
	}
:}
				|
				PRINT LPAREN Expr:dest OptNumbers RPAREN SEMI
{:
	if (dest != Tab.intType && dest != Tab.charType && dest != Tab.find("bool").getType() && dest != Tab.find("string").getType()) {
		parser.report_error("Greska na liniji "+destleft+": u pozivu read(Expr, [, number]) expr mora biti tipa int, char, bool ili string", null);
	}
:}
				|
				LBRACE StatementList RBRACE  {:
						parser.statementBlocks++;
					:}
				;
				
WhileLoop ::= WHILE {:
	insideWhile = true;
:}
;


OptNumbers ::= COMMA NUMBER
				|
				/* epsilon */
				;
				
ActParams ::= ActPars:dummy
{:
		int numOfFormPars = functionDesignator.getFpPos();
		if (numOfFormPars != numOfActPars) {
			parser.report_error("Greska : netacan broj stvarnih parametara u pozivu funkcije u liniji "+dummyleft, null);
		}
:}
				|
				/* epsilon */
{:
		
		int numOfFormPars;
		if (functionDesignator==null)
			numOfFormPars = currentDesignator.getFpPos();
		else
			numOfFormPars = functionDesignator.getFpPos();
		if (0 != numOfFormPars) {
			parser.report_error("Greska : netacan broj stvarnih parametara u pozivu funkcije", null);
		}
:}
				;
				
ActPars ::= ActPars COMMA ActPar
			|
			ActPar
			;

ActPar ::= Expr:e {:

	if (!lockFunctionDesignator) {
		lockFunctionDesignator = true;
		functionDesignator = currentDesignator.getKind()<2 || currentDesignator.getKind()>3 ? previosDesignator : currentDesignator;
	}

	Obj obj = null;
	int numOfFormPars = functionDesignator.getFpPos();
	if (numOfActPars >= numOfFormPars) {
		parser.report_error("Greska na liniji "+eleft+" vise stvarnih od formalnih parametara", null);
	}
	else {
		int i=0;
		Collection<Obj> col = functionDesignator.getLocalSymbols();
		for (Obj o: col) {
			if (i==numOfActPars) {
				obj = o;
				break;
			}
			i++;
		}
		if (e != obj.getType() || (obj.getType().getKind()==Struct.Array && e.getElemType() != obj.getType().getElemType())) {
		    parser.report_error(obj.getName(), eleft, "nekompatibilni tipovi stvarnih sa formalnim parametrima");
		}
		else {
	    	parser.report_info(obj.getName(), eleft, obj);
		}
	}
	numOfActPars++;
:};
			
Condition ::= Condition OR CondTerm
				|
				CondTerm
				;
				
CondTerm ::= CondTerm AND CondFact
				|
				CondFact
				;
				
CondFact ::= Expr:tip1 Relop:uporedi Expr:tip2
 {:
   			 if (!tip1.assignableTo(tip2)){
   				 parser.report_error(tip1.getName(), tip1left, "nekompatiblini tipovi");
   			 }
   			 else{
   				 if (tip1.getKind() == Struct.Array || tip2.getKind() == Struct.Class){
   					 if (uporedi > 1){
   						 parser.report_error(tip1.getName(), tip1left, "uz promenljiva tipa klase ili niza se mogu koristiti samo != i ==");
   					 }
   				 }
   			 }
   		 :}

				|
				Expr
				;
				
Expr ::= Sign Term:te AddList:t
{:
	if ((t==Tab.noType && te==Tab.intType) || (te.equals(t) && te==Tab.intType))
		RESULT = te;
	else {
		parser.report_error("Semanticka greska na liniji "+teleft+": nekompatibilni tipovu u izrazu za sabiranje", null);
		RESULT = Tab.noType;
	}
:} ;

Sign ::= MINUS  {:
   			 RESULT = 0;
   		 :}
| /* epsilon */  {:
   			 RESULT = 1;
   		 :}
;

AddList ::= AddList:te Addop:ao Term:t
{:
	if ((te==Tab.noType && t==Tab.intType ) || (te.equals(t) && te==Tab.intType))
		RESULT = t;
	else if (ao==0 && ((te==Tab.noType && t==Tab.find("string") ) || (te.equals(t) && te==Tab.find("string"))) {
		RESULT = t;
	}
	else {
		parser.report_error("Semanticka greska na liniji "+teleft+": nekompatibilni tipovu u izrazu za sabiranje 2", null);
		RESULT = Tab.noType;
	}
:}
			|
			/* epsilon */
{:
	RESULT = Tab.noType;
:}
			;
			
Term ::= Factor:te MulList:t
{:
	if ((t==Tab.noType && te==Tab.intType) || (te.equals(t) && te==Tab.intType))
		RESULT = te;
	else {
		parser.report_error("Semanticka greska na liniji "+teleft+": nekompatibilni tipovu u izrazu za mnozenje 2", null);
		RESULT = Tab.noType;
	}
:} ;

MulList ::= MulList:te Mulop Factor:t
{:
	if ((te==Tab.noType && te==Tab.intType) || (te.equals(t) && te==Tab.intType))
		RESULT = t;
	else {
		parser.report_error("Semanticka greska na liniji "+teleft+": nekompatibilni tipovu u izrazu za mnozenje", null);
		RESULT = Tab.noType;
	}
:}
			|
			/* epsilon */
{:
	RESULT = Tab.noType;
:}
			;
			
Factor ::= Designator:func LPAREN ActParams RPAREN
{:
	if (Obj.Meth == func.getKind()) {
		parser.report_info("Pronadjen poziv funkcije "+func.getName()+" na liniji "+funcleft, null);
		RESULT = func.getType();
	}
	else {
		parser.report_error("Semanticka greska na liniji "+funcleft+": ime "+func.getName()+" nije funkcija.", null);
		RESULT = Tab.noType;
	}
	
:}
			|
		   Designator:d {: RESULT = d.getType(); :}
			|
			NUMBER {: RESULT = Tab.intType; :}
			|
			CHARCONST {: RESULT = Tab.charType; :}
			|
			BOOLCONST {: RESULT = Tab.find("bool").getType(); :}
			|
			STRCONST {: RESULT = Tab.find("string").getType(); :}
			|
			NEW Type {:
				parser.newStatementCount++;
			:}
			|
			NEW Type LSQUARE Expr RSQUARE
			|
			LPAREN Expr RPAREN
			;
				
DesignatorsFollowUp ::= 
						INC
						|
						DEC
						;
				
Unmatched ::= IF LPAREN Condition RPAREN Statement
			 |
			 IF LPAREN error:l RPAREN Statement {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" unutar izraza u if konstrukciji.",null); :}
			 | 
			 IF LPAREN Condition RPAREN Matched ELSE Unmatched
			 |
			 IF LPAREN error:l RPAREN Matched ELSE Unmatched {: parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" unutar izraza u if konstrukciji.",null); :}
			 |
			 WhileLoop LPAREN Condition RPAREN  Unmatched {: insideWhile = false; :}
			 |
			 WhileLoop LPAREN error:l RPAREN Unmatched {: insideWhile = false; parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" unutar izraza u while konstrukciji.",null); :}
			 ;
					
Designator ::= IDENT:name
{:	
	previosDesignator = currentDesignator;
	Obj obj = currentDesignator = Tab.find(name);
	numOfActPars = 0;
	if (obj == Tab.noObj) {
		parser.report_error(name, nameleft, "nije deklarisano");
	}
	parser.report_info(name, nameleft, obj);
	RESULT = obj;
	curr_ident = obj;
	designatorIsArrElem = false;
:} IdentList;

IdentList ::= IdentList:il IdentRef:ir 
{: 
	if (ir != null)
		RESULT = ir;
	else
		RESULT = il;
:}
				|
				/* epsilon */ {: RESULT = Tab.noObj; :}
				;
				
IdentRef ::= DOT IDENT:ident
			{:
				if (curr_ident.getKind() == Struct.Class) {
					previosDesignator = currentDesignator;
					Obj obj = currentDesignator = Tab.find(ident);
					numOfActPars = 0;
					if (obj == Tab.noObj) {
						parser.report_error("Semanticka greska na liniji "+identleft+": ime "+ident+" nije deklarisano.", null);
					}
					RESULT = obj;
					curr_ident = obj;
					designatorIsArrElem = false;
					
				}
				else {
					parser.report_error("Semanticka greska u liniji "+identleft+": "+curr_ident.getName()+" mora biti promenljiva klasnog tipa.",null);
				}
			:}
			|
			LSQUARE:dummy Expr RSQUARE
			{:
				 designatorIsArrElem = true;
				 if (curr_ident.getType().getKind()!=Struct.Array) 
                              parser.report_error("Semanticka greska u liniji "+dummyleft+": Ocekivan niz na mestu identifikatora "+curr_ident.getName(),null);
			:}
			|
			LSQUARE error:l RSQUARE {: 
				designatorIsArrElem = true;
				parser.report_error("Izvrsen oporavak do ; u liniji "+lleft+" pri indeksiranju niza.",null);
			 :}
			;

Relop ::= IS_EQUAL
 {:
   			 RESULT = 0;
   		 :}

			|
			NOT_EQUAL
			 {:
   			 RESULT = 1;
   		 :}

			|
			GT
			 {:
   			 RESULT = 2;
   		 :}

			|
			GTE
			 {:
   			 RESULT = 3;
   		 :}

			|
			LT
			 {:
   			 RESULT = 4;
   		 :}

			|
			LTE
			 {:
   			 RESULT = 5;
   		 :}

			;

Addop ::= PLUS
 {:
   			 RESULT = 0;
   		 :}

			|
			MINUS
			 {:
   			 RESULT = 1;
   		 :}

			;
			
Mulop ::= TIMES
			|
			DIV
			|
			MOD
			;